from __future__ import annotations

from datetime import datetime
from typing import Any, Optional

from pydantic import BaseModel, ConfigDict, Field, HttpUrl

from .db_models import NegotiationStatus, WasteLotStatus


class ProducerBase(BaseModel):
    name: str
    contact_email: str
    organization_type: Optional[str] = None
    aptos_address: Optional[str] = Field(
        None, description="Aptos account address that will custody tokenized waste lots"
    )


class ProducerCreate(ProducerBase):
    ...


class ProducerRead(ProducerBase):
    id: int
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class WasteLotBase(BaseModel):
    material_type: str
    quantity_tons: float
    location: str
    price_floor_usd_per_ton: Optional[float] = Field(
        None, description="Minimum desired price in USD per ton"
    )
    external_reference: Optional[str] = Field(
        None, description="Producer-supplied reference such as manifest number"
    )
    chemical_composition: dict[str, Any] = Field(default_factory=dict)
    photos: list[HttpUrl] = Field(default_factory=list)


class WasteLotCreate(WasteLotBase):
    producer_id: int


class WasteLotRead(WasteLotBase):
    id: int
    producer_id: int
    status: WasteLotStatus
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class WasteLotVerificationCreate(BaseModel):
    method: str = Field(description="Verification method (e.g., video_upload, sensor_bundle)")
    evidence_uri: Optional[HttpUrl] = None
    sensor_checksum: Optional[str] = None
    verifier_notes: Optional[str] = None
    mark_verified: bool = Field(
        False, description="Immediately mark the lot as verified if evidence is accepted"
    )


class WasteLotVerificationRead(BaseModel):
    id: int
    status: str
    method: str
    evidence_uri: Optional[HttpUrl]
    sensor_checksum: Optional[str]
    verifier_notes: Optional[str]
    requested_at: datetime
    verified_at: Optional[datetime]

    model_config = ConfigDict(from_attributes=True)


class TokenMintRequest(BaseModel):
    token_name: str
    token_symbol: str
    supply: int = Field(1, ge=1, description="Number of tokens to mint for the lot")
    token_address: Optional[str] = Field(default=None, description="On-chain token address when minted via wallet")
    transaction_hash: Optional[str] = Field(default=None, description="Transaction hash from on-chain mint")


class WasteLotTokenRead(BaseModel):
    id: int
    token_address: str
    token_name: str
    token_symbol: str
    supply: int
    transaction_hash: Optional[str]
    minted_at: datetime
    retired_at: Optional[datetime]
    retire_transaction_hash: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class WasteLotDetail(WasteLotRead):
    token: Optional[WasteLotTokenRead] = None
    verification: Optional[WasteLotVerificationRead] = None
    proofs: list["UpcyclingProofRead"] = Field(default_factory=list)


class ProducerDetail(ProducerRead):
    lots: list[WasteLotRead] = Field(default_factory=list)
    agents: list["AgentRead"] = Field(default_factory=list)

    model_config = ConfigDict(from_attributes=True)


class VerificationApproval(BaseModel):
    verifier_notes: Optional[str] = None


class AgentBase(BaseModel):
    owner_name: str
    agent_type: str = Field(pattern=r"^(producer|recycler)$")
    owner_contact: Optional[str] = None
    producer_id: Optional[int] = Field(
        None, description="Link to producer record when this is a producer agent"
    )
    target_price_usd_per_ton: Optional[float] = None
    max_price_usd_per_ton: Optional[float] = None
    deadline_hours: Optional[int] = Field(None, ge=1)
    radius_miles: Optional[int] = Field(None, ge=0)
    auto_negotiate: Optional[bool] = True
    bundle_preference: Optional[bool] = False
    strategy_metadata: dict[str, Any] = Field(default_factory=dict)


class AgentCreate(AgentBase):
    agent_identifier: Optional[str] = Field(
        default=None, description="Custom identifier; autogenerated if omitted"
    )


class AgentRead(AgentBase):
    id: int
    agent_identifier: str
    last_heartbeat_at: Optional[datetime]
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class NegotiationRead(BaseModel):
    id: int
    waste_lot_id: int
    producer_agent_id: int
    recycler_agent_id: int
    status: NegotiationStatus
    producer_offer_usd_per_ton: Optional[float]
    recycler_offer_usd_per_ton: Optional[float]
    agreed_price_usd_per_ton: Optional[float]
    expires_at: datetime
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class NegotiationDecision(BaseModel):
    agree: bool
    counter_offer_usd_per_ton: Optional[float] = None
    notes: Optional[str] = None


class UpcyclingProofCreate(BaseModel):
    recycler_agent_id: Optional[int] = None
    evidence_uri: Optional[HttpUrl] = None
    sensor_checksum: Optional[str] = None
    processing_notes: Optional[str] = None


class UpcyclingProofRead(BaseModel):
    id: int
    waste_lot_id: int
    recycler_agent_id: Optional[int]
    evidence_uri: Optional[HttpUrl]
    sensor_checksum: Optional[str]
    processing_notes: Optional[str]
    ai_confidence: Optional[float]
    status: str
    certificate_uri: Optional[HttpUrl]
    submitted_at: datetime
    validated_at: Optional[datetime]

    model_config = ConfigDict(from_attributes=True)


class ProofValidationDecision(BaseModel):
    approve: bool
    ai_confidence: Optional[float] = Field(None, ge=0, le=1)
    certificate_uri: Optional[HttpUrl] = None
    notes: Optional[str] = None
